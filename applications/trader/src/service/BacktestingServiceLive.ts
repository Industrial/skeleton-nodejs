/**
 * @module BacktestingServiceLive
 * @description Live implementation of the BacktestingService.
 * Provides concrete implementations of backtesting operations.
 */

import { Effect, Schema } from 'effect'
import { v4 as uuidv4 } from 'uuid'
import {
  type BacktestState,
  BacktestStateSchema,
  type ProcessSignalsInput,
  ProcessSignalsInputSchema,
  RunBacktestInputSchema,
  RunParameterSweepInputSchema,
  RunWalkForwardOptimizationInputSchema,
} from '../domain/backtesting/Backtest'
import {
  type BacktestParameters,
  DefaultBacktestParametersSchema,
} from '../domain/backtesting/BacktestParameters'
import { PositionSizingMethod } from '../domain/backtesting/BacktestParameters'
import {
  type BacktestResult,
  BacktestResultSchema,
} from '../domain/backtesting/BacktestResult'
import type { Position } from '../domain/backtesting/Position'
import { PositionSchema } from '../domain/backtesting/Position'
import { PositionStatus } from '../domain/backtesting/PositionStatus'
import type { Trade } from '../domain/backtesting/Trade'
import { TradeDirection, TradeSchema } from '../domain/backtesting/Trade'
import type { Candlestick } from '../domain/market-data/Candlestick'
import type { Strategy } from '../domain/strategy/Strategy'
import { BacktestingError } from './BacktestingService'

// In-memory storage for backtest results
const backtestResultsStorage = new Map<string, BacktestResult>()

/**
 * Create an initial backtest state
 * @param initialCapital Initial capital for the backtest
 * @returns The initial backtest state
 */
const createInitialState = (
  initialCapital: number,
): Effect.Effect<BacktestState, BacktestingError, never> =>
  Effect.gen(function* (_) {
    try {
      return Schema.decodeSync(BacktestStateSchema)({
        equity: initialCapital,
        availableCapital: initialCapital,
        openPositions: [],
        closedPositions: [],
        trades: [],
        equityCurve: [],
        drawdownCurve: [],
        peakEquity: initialCapital,
        metadata: {},
      })
    } catch (error) {
      return yield* _(
        Effect.fail(
          new BacktestingError({
            message: `Failed to create initial backtest state: ${String(
              error,
            )}`,
            cause: error,
          }),
        ),
      )
    }
  })

/**
 * Process signals generated by a strategy
 * @param input Process signals input
 * @returns The final backtest state after processing all signals
 */
const processSignals = (
  input: ProcessSignalsInput,
): Effect.Effect<BacktestState, BacktestingError, never> =>
  Effect.gen(function* (_) {
    try {
      // Validate input
      const validatedInput = Schema.decodeSync(ProcessSignalsInputSchema)(input)
      const { signals, candlesticks, parameters, initialState } = validatedInput

      // Initialize state
      let currentState = initialState
      const openPositions = new Map<string, Position>() // Track open positions by ID
      const trades: Trade[] = []
      const closedPositions: Position[] = []
      const { v4: uuidv4 } = yield* _(Effect.sync(() => require('uuid')))

      // Process each signal with corresponding candlestick
      for (let i = 0; i < signals.length; i++) {
        const signal = signals[i]
        const candlestick = candlesticks[i]

        if (!signal || !candlestick) continue

        // Process the signal based on its direction
        switch (signal.direction) {
          case 'buy': {
            // Check if we can open a new position based on parameters
            if (
              parameters.maxConcurrentPositions > 0 &&
              openPositions.size >= parameters.maxConcurrentPositions
            ) {
              // Skip if we've reached the maximum number of concurrent positions
              break
            }

            // Calculate position size based on the sizing method
            let positionSize = 0
            const availableCapital = currentState.availableCapital

            switch (parameters.positionSizingMethod) {
              case PositionSizingMethod.Fixed:
                // Fixed size in units
                positionSize = parameters.positionSizeValue
                break
              case PositionSizingMethod.PercentageOfCapital:
                // Percentage of available capital
                positionSize =
                  (availableCapital * parameters.positionSizeValue) /
                  100 /
                  signal.price
                break
              case PositionSizingMethod.RiskBased:
                // Risk-based sizing (simplified)
                positionSize =
                  (availableCapital * parameters.positionSizeValue) /
                  100 /
                  signal.price
                break
              case PositionSizingMethod.Kelly:
                // Kelly criterion (simplified)
                positionSize =
                  (availableCapital * parameters.positionSizeValue) /
                  100 /
                  signal.price
                break
            }

            // Apply slippage to the price (buy at a slightly higher price)
            const slippageAdjustedPrice =
              signal.price * (1 + parameters.slippageRate)

            // Calculate fees
            const fees =
              slippageAdjustedPrice * positionSize * parameters.feeRate

            // Create a buy trade
            const buyTrade = Schema.decodeSync(TradeSchema)({
              id: uuidv4(),
              direction: TradeDirection.Buy,
              price: slippageAdjustedPrice,
              volume: positionSize,
              timestamp: candlestick.timestamp,
              fees,
              metadata: {
                signalStrength: signal.strength,
                candlestick: {
                  open: candlestick.open,
                  high: candlestick.high,
                  low: candlestick.low,
                  close: candlestick.close,
                  volume: candlestick.volume,
                },
              },
            })

            // Add the trade to our list
            trades.push(buyTrade)

            // Create a new position
            const positionId = uuidv4()
            const newPosition = Schema.decodeSync(PositionSchema)({
              id: positionId,
              status: PositionStatus.Open,
              direction: TradeDirection.Buy,
              entryPrice: slippageAdjustedPrice,
              size: positionSize,
              openTimestamp: candlestick.timestamp,
              entryTrade: buyTrade,
              metadata: {
                signalMetadata: signal.metadata,
              },
            })

            // Add to open positions
            openPositions.set(positionId, newPosition)

            // Update available capital
            const cost = slippageAdjustedPrice * positionSize + fees
            currentState = {
              ...currentState,
              availableCapital: availableCapital - cost,
              openPositions: Array.from(openPositions.values()),
            }
            break
          }
          case 'sell': {
            // Close any open positions if we have a sell signal
            if (openPositions.size > 0) {
              // In a real implementation, we might be more selective about which positions to close
              // For simplicity, we'll close the oldest position first
              const positionsArray = Array.from(openPositions.values())
              const oldestPosition = positionsArray.reduce((oldest, current) =>
                oldest.openTimestamp < current.openTimestamp ? oldest : current,
              )

              // Apply slippage to the price (sell at a slightly lower price)
              const slippageAdjustedPrice =
                signal.price * (1 - parameters.slippageRate)

              // Calculate fees
              const fees =
                slippageAdjustedPrice * oldestPosition.size * parameters.feeRate

              // Create a sell trade
              const sellTrade = Schema.decodeSync(TradeSchema)({
                id: uuidv4(),
                direction: TradeDirection.Sell,
                price: slippageAdjustedPrice,
                volume: oldestPosition.size,
                timestamp: candlestick.timestamp,
                fees,
                metadata: {
                  signalStrength: signal.strength,
                  candlestick: {
                    open: candlestick.open,
                    high: candlestick.high,
                    low: candlestick.low,
                    close: candlestick.close,
                    volume: candlestick.volume,
                  },
                },
              })

              // Add the trade to our list
              trades.push(sellTrade)

              // Close the position
              const closedPosition = Schema.decodeSync(PositionSchema)({
                ...oldestPosition,
                status: PositionStatus.Closed,
                exitPrice: slippageAdjustedPrice,
                closeTimestamp: candlestick.timestamp,
                exitTrade: sellTrade,
              })

              // Remove from open positions and add to closed positions
              openPositions.delete(oldestPosition.id)
              closedPositions.push(closedPosition)

              // Calculate profit/loss
              const entryValue = oldestPosition.entryPrice * oldestPosition.size
              const exitValue = slippageAdjustedPrice * oldestPosition.size
              const totalFees =
                (oldestPosition.entryTrade?.fees || 0) + sellTrade.fees
              const profitLoss = exitValue - entryValue - totalFees

              // Update equity and available capital
              const newEquity = currentState.equity + profitLoss
              const newAvailableCapital =
                currentState.availableCapital + exitValue - fees

              currentState = {
                ...currentState,
                equity: newEquity,
                availableCapital: newAvailableCapital,
                openPositions: Array.from(openPositions.values()),
                closedPositions: [
                  ...currentState.closedPositions,
                  closedPosition,
                ],
                trades: [...currentState.trades, sellTrade],
              }
            }
            break
          }
          // For 'none' signals, we don't take any action
          default:
            break
        }

        // Update equity curve
        currentState = {
          ...currentState,
          equityCurve: [
            ...currentState.equityCurve,
            [candlestick.timestamp, currentState.equity],
          ],
        }

        // Calculate drawdown
        const currentDrawdown =
          currentState.peakEquity > 0
            ? ((currentState.peakEquity - currentState.equity) /
                currentState.peakEquity) *
              100
            : 0
        currentState = {
          ...currentState,
          drawdownCurve: [
            ...currentState.drawdownCurve,
            [candlestick.timestamp, currentDrawdown],
          ],
        }

        // Update peak equity if needed
        if (currentState.equity > currentState.peakEquity) {
          currentState = {
            ...currentState,
            peakEquity: currentState.equity,
          }
        }
      }

      // Close any remaining open positions at the last price
      if (openPositions.size > 0 && candlesticks.length > 0) {
        const lastCandlestick = candlesticks[candlesticks.length - 1]
        const lastPrice = lastCandlestick.close

        for (const position of openPositions.values()) {
          // Apply slippage to the price (sell at a slightly lower price)
          const slippageAdjustedPrice =
            lastPrice * (1 - parameters.slippageRate)

          // Calculate fees
          const fees =
            slippageAdjustedPrice * position.size * parameters.feeRate

          // Create a sell trade
          const sellTrade = Schema.decodeSync(TradeSchema)({
            id: uuidv4(),
            direction: TradeDirection.Sell,
            price: slippageAdjustedPrice,
            volume: position.size,
            timestamp: lastCandlestick.timestamp,
            fees,
            metadata: {
              forcedClose: true,
              candlestick: {
                open: lastCandlestick.open,
                high: lastCandlestick.high,
                low: lastCandlestick.low,
                close: lastCandlestick.close,
                volume: lastCandlestick.volume,
              },
            },
          })

          // Add the trade to our list
          trades.push(sellTrade)

          // Close the position
          const closedPosition = Schema.decodeSync(PositionSchema)({
            ...position,
            status: PositionStatus.Closed,
            exitPrice: slippageAdjustedPrice,
            closeTimestamp: lastCandlestick.timestamp,
            exitTrade: sellTrade,
          })

          // Add to closed positions
          closedPositions.push(closedPosition)

          // Calculate profit/loss
          const entryValue = position.entryPrice * position.size
          const exitValue = slippageAdjustedPrice * position.size
          const totalFees = (position.entryTrade?.fees || 0) + sellTrade.fees
          const profitLoss = exitValue - entryValue - totalFees

          // Update equity and available capital
          currentState = {
            ...currentState,
            equity: currentState.equity + profitLoss,
            availableCapital: currentState.availableCapital + exitValue - fees,
          }
        }

        // Update final state
        currentState = {
          ...currentState,
          openPositions: [],
          closedPositions: [
            ...currentState.closedPositions,
            ...closedPositions,
          ],
          trades: [...currentState.trades, ...trades],
        }

        // Update final equity curve and drawdown
        if (candlesticks.length > 0) {
          const lastTimestamp = candlesticks[candlesticks.length - 1].timestamp
          currentState = {
            ...currentState,
            equityCurve: [
              ...currentState.equityCurve,
              [lastTimestamp, currentState.equity],
            ],
          }

          const finalDrawdown =
            currentState.peakEquity > 0
              ? ((currentState.peakEquity - currentState.equity) /
                  currentState.peakEquity) *
                100
              : 0
          currentState = {
            ...currentState,
            drawdownCurve: [
              ...currentState.drawdownCurve,
              [lastTimestamp, finalDrawdown],
            ],
          }
        }
      }

      return currentState
    } catch (error) {
      return yield* _(
        Effect.fail(
          new BacktestingError({
            message: `Failed to process signals: ${String(error)}`,
            cause: error,
          }),
        ),
      )
    }
  })

/**
 * Run a backtest with the specified strategy, candlesticks, and parameters
 * @param strategy The trading strategy to test
 * @param candlesticks Historical price data to test against
 * @param parameters Backtest configuration parameters
 * @param name Optional name for the backtest
 * @param description Optional description for the backtest
 * @returns Effect containing the backtest result
 */
const runBacktest = (
  strategy: Strategy,
  candlesticks: Candlestick[],
  parameters: BacktestParameters,
  name?: string,
  description?: string,
): Effect.Effect<BacktestResult, BacktestingError, never> =>
  Effect.gen(function* (_) {
    try {
      // Validate input
      const validatedInput = Schema.decodeSync(RunBacktestInputSchema)({
        strategy,
        candlesticks,
        parameters,
        name,
        description,
      })

      // Record start time for performance measurement
      const startTime = Date.now()

      // Generate signals from the strategy
      console.log(
        `Generating signals using ${validatedInput.strategy.name} strategy...`,
      )
      const signals = yield* _(
        strategy.analyze(candlesticks).pipe(
          Effect.mapError(
            (error) =>
              new BacktestingError({
                message: `Failed to generate signals: ${String(error)}`,
                cause: error,
              }),
          ),
        ),
      )
      console.log(`Generated ${signals.length} signals`)

      // Create initial state
      const initialState = yield* _(
        createInitialState(parameters.initialCapital),
      )

      // Process signals
      console.log('Processing signals and simulating trades...')
      const finalState = yield* _(
        processSignals({
          signals,
          candlesticks,
          parameters,
          initialState,
        }),
      )

      // Record end time for performance measurement
      const endTime = Date.now()
      const executionTime = endTime - startTime

      // Calculate performance metrics
      const trades = finalState.trades
      const positions = [
        ...Array.from(finalState.openPositions),
        ...Array.from(finalState.closedPositions),
      ]

      // Calculate basic metrics
      const totalReturn = finalState.equity - parameters.initialCapital
      const totalReturnPercentage =
        (totalReturn / parameters.initialCapital) * 100
      const numberOfTrades = trades.length

      // Calculate winning and losing trades
      let winningTrades = 0
      let losingTrades = 0
      let totalProfit = 0
      let totalLoss = 0
      let consecutiveWins = 0
      let consecutiveLosses = 0
      let maxConsecutiveWins = 0
      let maxConsecutiveLosses = 0
      let totalHoldingPeriod = 0

      // Calculate max drawdown
      let maxDrawdown = 0
      let maxDrawdownPercentage = 0
      if (finalState.drawdownCurve.length > 0) {
        maxDrawdownPercentage = Math.max(
          ...finalState.drawdownCurve.map(([, drawdown]) => drawdown),
        )
        maxDrawdown = (maxDrawdownPercentage / 100) * parameters.initialCapital
      }

      // Process closed positions to calculate metrics
      for (const position of positions) {
        if (position.status === PositionStatus.Closed && position.exitPrice) {
          const entryValue = position.entryPrice * position.size
          const exitValue = position.exitPrice * position.size
          const entryFees = position.entryTrade?.fees || 0
          const exitFees = position.exitTrade?.fees || 0
          const totalFees = entryFees + exitFees
          const profitLoss = exitValue - entryValue - totalFees

          if (profitLoss > 0) {
            winningTrades++
            totalProfit += profitLoss
            consecutiveWins++
            consecutiveLosses = 0
            maxConsecutiveWins = Math.max(maxConsecutiveWins, consecutiveWins)
          } else {
            losingTrades++
            totalLoss += Math.abs(profitLoss)
            consecutiveLosses++
            consecutiveWins = 0
            maxConsecutiveLosses = Math.max(
              maxConsecutiveLosses,
              consecutiveLosses,
            )
          }

          // Calculate holding period
          if (position.openTimestamp && position.closeTimestamp) {
            const holdingPeriod =
              position.closeTimestamp - position.openTimestamp
            totalHoldingPeriod += holdingPeriod
          }
        }
      }

      // Calculate derived metrics
      const winRate =
        numberOfTrades > 0 ? (winningTrades / numberOfTrades) * 100 : 0
      const averageProfit = winningTrades > 0 ? totalProfit / winningTrades : 0
      const averageLoss = losingTrades > 0 ? totalLoss / losingTrades : 0
      const profitFactor =
        totalLoss > 0
          ? totalProfit / totalLoss
          : totalProfit > 0
            ? Number.POSITIVE_INFINITY
            : 0
      const averageHoldingPeriod =
        positions.length > 0 ? totalHoldingPeriod / positions.length : 0

      // Create backtest result
      const backtestResult = Schema.decodeSync(BacktestResultSchema)({
        id: uuidv4(),
        name: name || `Backtest ${new Date().toISOString()}`,
        description,
        parameters,
        trades: Array.from(finalState.trades),
        positions,
        metrics: {
          totalReturn,
          totalReturnPercentage,
          numberOfTrades,
          winningTrades,
          losingTrades,
          winRate,
          averageProfit,
          averageLoss,
          profitFactor,
          maxDrawdown,
          maxDrawdownPercentage,
          maxConsecutiveWins,
          maxConsecutiveLosses,
          averageHoldingPeriod,
        },
        startTimestamp: candlesticks[0]?.timestamp || Date.now(),
        endTimestamp:
          candlesticks[candlesticks.length - 1]?.timestamp || Date.now(),
        runTimestamp: startTime,
        executionTime,
        metadata: {
          equityCurve: finalState.equityCurve,
          drawdownCurve: finalState.drawdownCurve,
          strategy: {
            name: strategy.name,
            description: strategy.description,
            parameters: strategy.parameters,
          },
        },
      })

      // Log summary
      console.log(`Backtest completed: ${backtestResult.name}`)
      console.log(
        `Total return: ${totalReturn.toFixed(2)} (${totalReturnPercentage.toFixed(2)}%)`,
      )
      console.log(`Win rate: ${winRate.toFixed(2)}%`)
      console.log(`Profit factor: ${profitFactor.toFixed(2)}`)
      console.log(`Max drawdown: ${maxDrawdownPercentage.toFixed(2)}%`)
      console.log(`Total trades: ${numberOfTrades}`)

      return backtestResult
    } catch (error) {
      return yield* _(
        Effect.fail(
          new BacktestingError({
            message: `Failed to run backtest: ${String(error)}`,
            cause: error,
          }),
        ),
      )
    }
  })

/**
 * Run multiple backtests with different parameters
 * @param strategy The trading strategy to test
 * @param candlesticks Historical price data to test against
 * @param parametersList List of backtest configuration parameters
 * @param namePrefix Optional prefix for backtest names
 * @returns Effect containing an array of backtest results
 */
const runParameterSweep = (
  strategy: Strategy,
  candlesticks: Candlestick[],
  parametersList: BacktestParameters[],
  namePrefix?: string,
): Effect.Effect<BacktestResult[], BacktestingError, never> =>
  Effect.gen(function* (_) {
    try {
      // Validate input
      const validatedInput = Schema.decodeSync(RunParameterSweepInputSchema)({
        strategy,
        candlesticks,
        parametersList,
        namePrefix,
      })

      // Run backtests for each parameter set
      const results: BacktestResult[] = []
      for (let i = 0; i < parametersList.length; i++) {
        const parameters = parametersList[i]
        const name = `${namePrefix || 'Sweep'} #${i + 1}`
        const result = yield* _(
          runBacktest(strategy, candlesticks, parameters, name),
        )
        results.push(result)
      }

      return results
    } catch (error) {
      return yield* _(
        Effect.fail(
          new BacktestingError({
            message: `Failed to run parameter sweep: ${String(error)}`,
            cause: error,
          }),
        ),
      )
    }
  })

/**
 * Run a walk-forward optimization
 * @param strategy The trading strategy to test
 * @param candlesticks Historical price data to test against
 * @param parametersList List of backtest configuration parameters to optimize
 * @param inSamplePercentage Percentage of data to use for in-sample optimization
 * @param numFolds Number of folds for walk-forward optimization
 * @param namePrefix Optional prefix for backtest names
 * @returns Effect containing the optimized backtest result
 */
const runWalkForwardOptimization = (
  strategy: Strategy,
  candlesticks: Candlestick[],
  parametersList: BacktestParameters[],
  inSamplePercentage: number,
  numFolds: number,
  namePrefix?: string,
): Effect.Effect<BacktestResult, BacktestingError, never> =>
  Effect.gen(function* (_) {
    try {
      // Validate input
      const validatedInput = Schema.decodeSync(
        RunWalkForwardOptimizationInputSchema,
      )({
        strategy,
        candlesticks,
        parametersList,
        inSamplePercentage,
        numFolds,
        namePrefix,
      })

      // This is a placeholder implementation
      // In a real implementation, this would:
      // 1. Split data into folds
      // 2. For each fold, optimize parameters on in-sample data
      // 3. Test optimized parameters on out-of-sample data
      // 4. Combine results

      // For now, just run a backtest with the first parameter set
      const defaultParams = Schema.decodeSync(DefaultBacktestParametersSchema)({
        initialCapital: 10000,
        feeRate: 0.001,
        slippageRate: 0.001,
        positionSizingMethod: PositionSizingMethod.PercentageOfCapital,
        positionSizeValue: 10,
        reinvestProfits: true,
        maxConcurrentPositions: 0,
      })

      const result = yield* _(
        runBacktest(
          strategy,
          candlesticks,
          parametersList[0] || defaultParams,
          `${namePrefix || 'WFO'} Result`,
        ),
      )

      return result
    } catch (error) {
      return yield* _(
        Effect.fail(
          new BacktestingError({
            message: `Failed to run walk-forward optimization: ${String(
              error,
            )}`,
            cause: error,
          }),
        ),
      )
    }
  })

/**
 * Get all trades from a backtest
 * @param result The backtest result
 * @returns Array of trades
 */
const getTrades = (result: BacktestResult): Trade[] => {
  return Array.from(result.trades)
}

/**
 * Get all positions from a backtest
 * @param result The backtest result
 * @returns Array of positions
 */
const getPositions = (result: BacktestResult): Position[] => {
  return Array.from(result.positions)
}

/**
 * Get the equity curve from a backtest
 * @param result The backtest result
 * @returns Array of [timestamp, equity] tuples
 */
const getEquityCurve = (result: BacktestResult): [number, number][] => {
  return Array.from(result.metadata?.equityCurve as [number, number][]) || []
}

/**
 * Get the drawdown curve from a backtest
 * @param result The backtest result
 * @returns Array of [timestamp, drawdown percentage] tuples
 */
const getDrawdownCurve = (result: BacktestResult): [number, number][] => {
  return Array.from(result.metadata?.drawdownCurve as [number, number][]) || []
}

/**
 * Save a backtest result to storage
 * @param result The backtest result to save
 * @returns Effect containing the saved backtest result ID
 */
const saveBacktestResult = (
  result: BacktestResult,
): Effect.Effect<string, BacktestingError, never> =>
  Effect.gen(function* (_) {
    try {
      // Store the result in memory
      backtestResultsStorage.set(result.id, result)
      return result.id
    } catch (error) {
      return yield* _(
        Effect.fail(
          new BacktestingError({
            message: `Failed to save backtest result: ${String(error)}`,
            cause: error,
          }),
        ),
      )
    }
  })

/**
 * Load a backtest result from storage
 * @param id The ID of the backtest result to load
 * @returns Effect containing the loaded backtest result
 */
const loadBacktestResult = (
  id: string,
): Effect.Effect<BacktestResult, BacktestingError, never> =>
  Effect.gen(function* (_) {
    try {
      // Retrieve the result from memory
      const result = backtestResultsStorage.get(id)
      if (!result) {
        return yield* _(
          Effect.fail(
            new BacktestingError({
              message: `Backtest result with ID ${id} not found`,
            }),
          ),
        )
      }
      return result
    } catch (error) {
      return yield* _(
        Effect.fail(
          new BacktestingError({
            message: `Failed to load backtest result: ${String(error)}`,
            cause: error,
          }),
        ),
      )
    }
  })

/**
 * List all saved backtest results
 * @returns Effect containing an array of backtest result IDs and names
 */
const listBacktestResults = (): Effect.Effect<
  Array<{ id: string; name: string }>,
  BacktestingError,
  never
> =>
  Effect.gen(function* (_) {
    try {
      // Get all results from memory
      return Array.from(backtestResultsStorage.values()).map((result) => ({
        id: result.id,
        name: result.name,
      }))
    } catch (error) {
      return yield* _(
        Effect.fail(
          new BacktestingError({
            message: `Failed to list backtest results: ${String(error)}`,
            cause: error,
          }),
        ),
      )
    }
  })

/**
 * Delete a backtest result from storage
 * @param id The ID of the backtest result to delete
 * @returns Effect containing a boolean indicating success
 */
const deleteBacktestResult = (
  id: string,
): Effect.Effect<boolean, BacktestingError, never> =>
  Effect.gen(function* (_) {
    try {
      // Delete the result from memory
      return backtestResultsStorage.delete(id)
    } catch (error) {
      return yield* _(
        Effect.fail(
          new BacktestingError({
            message: `Failed to delete backtest result: ${String(error)}`,
            cause: error,
          }),
        ),
      )
    }
  })

/**
 * Live implementation of the BacktestingService
 */
export const BacktestingServiceLive = {
  runBacktest,
  runParameterSweep,
  runWalkForwardOptimization,
  getTrades,
  getPositions,
  getEquityCurve,
  getDrawdownCurve,
  saveBacktestResult,
  loadBacktestResult,
  listBacktestResults,
  deleteBacktestResult,
}
