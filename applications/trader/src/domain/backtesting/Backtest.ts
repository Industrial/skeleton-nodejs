/**
 * @module Backtest
 * @description Domain model for backtesting.
 * Defines the core data structures and schemas for backtesting.
 */

import { Schema } from 'effect'
import type { Candlestick } from '../market-data/Candlestick'
import type { Signal } from '../strategy/Signal'
import type { Strategy } from '../strategy/Strategy'
import type { BacktestParameters } from './BacktestParameters'
import { BacktestParametersSchema } from './BacktestParameters'
import type { BacktestResult } from './BacktestResult'
import type { Position } from './Position'
import type { Trade } from './Trade'

/**
 * Schema for backtest state metadata
 */
export const BacktestStateMetadataSchema = Schema.Record({
  key: Schema.String,
  value: Schema.Unknown,
})

/**
 * Type for validated backtest state metadata
 */
export type BacktestStateMetadataType = Schema.Schema.Type<
  typeof BacktestStateMetadataSchema
>

/**
 * Schema for backtest state
 */
export const BacktestStateSchema = Schema.Struct({
  /** Current equity (initial capital + profits/losses) */
  equity: Schema.Number.pipe(
    Schema.nonNegative({
      message: () => 'Equity must be non-negative',
    }),
  ),

  /** Available capital for new positions */
  availableCapital: Schema.Number.pipe(
    Schema.nonNegative({
      message: () => 'Available capital must be non-negative',
    }),
  ),

  /** Currently open positions */
  openPositions: Schema.Array(Schema.Any), // We'll validate this separately

  /** Closed positions */
  closedPositions: Schema.Array(Schema.Any), // We'll validate this separately

  /** All executed trades */
  trades: Schema.Array(Schema.Any), // We'll validate this separately

  /** Equity curve [timestamp, equity] */
  equityCurve: Schema.Array(Schema.Tuple(Schema.Number, Schema.Number)),

  /** Drawdown curve [timestamp, drawdownPercentage] */
  drawdownCurve: Schema.Array(Schema.Tuple(Schema.Number, Schema.Number)),

  /** Peak equity (for drawdown calculation) */
  peakEquity: Schema.Number.pipe(
    Schema.nonNegative({
      message: () => 'Peak equity must be non-negative',
    }),
  ),

  /** Optional metadata for additional state information */
  metadata: Schema.optional(BacktestStateMetadataSchema),
})

/**
 * Type for validated backtest state
 */
export type BacktestState = Schema.Schema.Type<typeof BacktestStateSchema>

/**
 * Schema for initial backtest state input
 */
export const InitialBacktestStateInputSchema = Schema.Struct({
  /** Initial capital for the backtest */
  initialCapital: Schema.Number.pipe(
    Schema.positive({
      message: () => 'Initial capital must be positive',
    }),
  ),
})

/**
 * Type for initial backtest state input
 */
export type InitialBacktestStateInput = Schema.Schema.Type<
  typeof InitialBacktestStateInputSchema
>

/**
 * Schema for process signals input
 */
export const ProcessSignalsInputSchema = Schema.Struct({
  /** Signals generated by the strategy */
  signals: Schema.Array(Schema.Any), // We'll validate this separately

  /** Historical price data */
  candlesticks: Schema.Array(Schema.Any), // We'll validate this separately

  /** Backtest configuration parameters */
  parameters: BacktestParametersSchema,

  /** Initial backtest state */
  initialState: BacktestStateSchema,
})

/**
 * Type for process signals input
 */
export type ProcessSignalsInput = Schema.Schema.Type<
  typeof ProcessSignalsInputSchema
>

/**
 * Schema for process signal input
 */
export const ProcessSignalInputSchema = Schema.Struct({
  /** Signal to process */
  signal: Schema.Any, // We'll validate this separately

  /** Current candlestick */
  candlestick: Schema.Any, // We'll validate this separately

  /** Backtest configuration parameters */
  parameters: BacktestParametersSchema,

  /** Current backtest state */
  state: BacktestStateSchema,
})

/**
 * Type for process signal input
 */
export type ProcessSignalInput = Schema.Schema.Type<
  typeof ProcessSignalInputSchema
>

/**
 * Schema for close open positions input
 */
export const CloseOpenPositionsInputSchema = Schema.Struct({
  /** Current backtest state */
  state: BacktestStateSchema,

  /** Last candlestick in the backtest */
  lastCandlestick: Schema.Any, // We'll validate this separately

  /** Backtest configuration parameters */
  parameters: BacktestParametersSchema,
})

/**
 * Type for close open positions input
 */
export type CloseOpenPositionsInput = Schema.Schema.Type<
  typeof CloseOpenPositionsInputSchema
>

/**
 * Schema for update equity curve input
 */
export const UpdateEquityCurveInputSchema = Schema.Struct({
  /** Current backtest state */
  state: BacktestStateSchema,

  /** Current timestamp */
  timestamp: Schema.Number.pipe(
    Schema.positive({
      message: () => 'Timestamp must be positive',
    }),
  ),
})

/**
 * Type for update equity curve input
 */
export type UpdateEquityCurveInput = Schema.Schema.Type<
  typeof UpdateEquityCurveInputSchema
>

/**
 * Schema for run backtest input
 */
export const RunBacktestInputSchema = Schema.Struct({
  /** Trading strategy to test */
  strategy: Schema.Any, // We'll validate this separately

  /** Historical price data */
  candlesticks: Schema.Array(Schema.Any), // We'll validate this separately

  /** Backtest configuration parameters */
  parameters: BacktestParametersSchema,

  /** Optional name for the backtest */
  name: Schema.optional(Schema.String),

  /** Optional description for the backtest */
  description: Schema.optional(Schema.String),
})

/**
 * Type for run backtest input
 */
export type RunBacktestInput = Schema.Schema.Type<typeof RunBacktestInputSchema>

/**
 * Schema for run parameter sweep input
 */
export const RunParameterSweepInputSchema = Schema.Struct({
  /** Trading strategy to test */
  strategy: Schema.Any, // We'll validate this separately

  /** Historical price data */
  candlesticks: Schema.Array(Schema.Any), // We'll validate this separately

  /** List of backtest configuration parameters */
  parametersList: Schema.Array(BacktestParametersSchema),

  /** Optional prefix for backtest names */
  namePrefix: Schema.optional(Schema.String),
})

/**
 * Type for run parameter sweep input
 */
export type RunParameterSweepInput = Schema.Schema.Type<
  typeof RunParameterSweepInputSchema
>

/**
 * Schema for run walk-forward optimization input
 */
export const RunWalkForwardOptimizationInputSchema = Schema.Struct({
  /** Trading strategy to test */
  strategy: Schema.Any, // We'll validate this separately

  /** Historical price data */
  candlesticks: Schema.Array(Schema.Any), // We'll validate this separately

  /** List of backtest configuration parameters to optimize */
  parametersList: Schema.Array(BacktestParametersSchema),

  /** Percentage of data to use for in-sample optimization */
  inSamplePercentage: Schema.Number.pipe(
    Schema.filter((value) => value > 0 && value < 100, {
      message: () => 'In-sample percentage must be between 0 and 100',
    }),
  ),

  /** Number of folds for walk-forward optimization */
  numFolds: Schema.Number.pipe(
    Schema.positive({
      message: () => 'Number of folds must be positive',
    }),
  ),

  /** Optional prefix for backtest names */
  namePrefix: Schema.optional(Schema.String),
})

/**
 * Type for run walk-forward optimization input
 */
export type RunWalkForwardOptimizationInput = Schema.Schema.Type<
  typeof RunWalkForwardOptimizationInputSchema
>
