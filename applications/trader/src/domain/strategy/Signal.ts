/**
 * @module Signal
 * @description Domain model for trading signals generated by strategies.
 * Provides types and validation for buy/sell signals with associated metadata.
 */

import { Data, Effect, Schema } from 'effect'

/**
 * Enum for signal directions
 */
export enum SignalDirection {
  /** Buy signal (enter long position) */
  Buy = 'buy',
  /** Sell signal (exit long position or enter short position) */
  Sell = 'sell',
  /** No action signal */
  None = 'none',
}

/**
 * Error thrown when signal parameters are invalid
 */
export class InvalidSignalError extends Data.TaggedError('InvalidSignalError')<{
  readonly message: string
}> {}

/**
 * Interface for signal parameters
 */
export interface SignalParams {
  /** Direction of the signal (buy, sell, none) */
  direction: SignalDirection
  /** Price at which the signal was generated */
  price: number
  /** Timestamp when the signal was generated (Unix timestamp in milliseconds) */
  timestamp: number
  /** Optional strength of the signal (0.0 to 1.0) */
  strength?: number
  /** Optional metadata for additional signal information */
  metadata?: Record<string, unknown>
}

/**
 * Schema for signal data
 */
export const SignalSchema = Schema.Struct({
  direction: Schema.Enums(SignalDirection),
  price: Schema.Number,
  timestamp: Schema.Number,
  strength: Schema.optional(Schema.Number),
  metadata: Schema.optional(
    Schema.Record({
      key: Schema.String,
      value: Schema.Unknown,
    }),
  ),
})

/**
 * Type for validated signal
 */
export type Signal = Schema.Schema.Type<typeof SignalSchema>

/**
 * Creates a validated signal
 * @param params Signal parameters
 * @returns Effect containing the validated signal
 * @throws {InvalidSignalError} When signal parameters are invalid
 * @example
 * ```ts
 * const signal = createSignal({
 *   direction: SignalDirection.Buy,
 *   price: 50000,
 *   timestamp: Date.now(),
 *   strength: 0.8,
 *   metadata: { indicator: 'MACD', value: 0.5 }
 * })
 * ```
 */
export const createSignal = (
  params: SignalParams,
): Effect.Effect<Signal, InvalidSignalError, never> =>
  Effect.gen(function* (_) {
    // Validate price
    if (params.price < 0) {
      return yield* _(
        Effect.fail(
          new InvalidSignalError({
            message: 'Price must be non-negative',
          }),
        ),
      )
    }

    // Validate timestamp
    if (params.timestamp <= 0) {
      return yield* _(
        Effect.fail(
          new InvalidSignalError({
            message: 'Timestamp must be positive',
          }),
        ),
      )
    }

    // Validate strength if provided
    if (
      params.strength !== undefined &&
      (params.strength < 0 || params.strength > 1)
    ) {
      return yield* _(
        Effect.fail(
          new InvalidSignalError({
            message: 'Strength must be between 0 and 1',
          }),
        ),
      )
    }

    // If all validations pass, decode the data
    try {
      return Schema.decodeSync(SignalSchema)(params)
    } catch (error) {
      return yield* _(
        Effect.fail(
          new InvalidSignalError({
            message: `Invalid signal parameters: ${String(error)}`,
          }),
        ),
      )
    }
  })

/**
 * Creates a buy signal
 * @param price Price at which to buy
 * @param timestamp Timestamp of the signal
 * @param options Additional options (strength, metadata)
 * @returns Effect containing the validated buy signal
 */
export const createBuySignal = (
  price: number,
  timestamp: number,
  options?: {
    strength?: number
    metadata?: Record<string, unknown>
  },
): Effect.Effect<Signal, InvalidSignalError, never> =>
  createSignal({
    direction: SignalDirection.Buy,
    price,
    timestamp,
    strength: options?.strength,
    metadata: options?.metadata,
  })

/**
 * Creates a sell signal
 * @param price Price at which to sell
 * @param timestamp Timestamp of the signal
 * @param options Additional options (strength, metadata)
 * @returns Effect containing the validated sell signal
 */
export const createSellSignal = (
  price: number,
  timestamp: number,
  options?: {
    strength?: number
    metadata?: Record<string, unknown>
  },
): Effect.Effect<Signal, InvalidSignalError, never> =>
  createSignal({
    direction: SignalDirection.Sell,
    price,
    timestamp,
    strength: options?.strength,
    metadata: options?.metadata,
  })

/**
 * Creates a no-action signal
 * @param price Current price
 * @param timestamp Timestamp of the signal
 * @param options Additional options (metadata)
 * @returns Effect containing the validated no-action signal
 */
export const createNoSignal = (
  price: number,
  timestamp: number,
  options?: {
    metadata?: Record<string, unknown>
  },
): Effect.Effect<Signal, InvalidSignalError, never> =>
  createSignal({
    direction: SignalDirection.None,
    price,
    timestamp,
    strength: 0,
    metadata: options?.metadata,
  })
